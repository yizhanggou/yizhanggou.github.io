---
title: "annoy索引读后感（二）：mmap"
author: 一张狗
lastmod: 2019-07-06 08:42:10
date: 2018-07-31 15:46:00
tags: []
---



## 一、概念

*mmap*：

功能描述：*mmap*将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。*munmap*执行相反的操作，删除特定地址区域的对象映射。
![200501092691998](http://yizhanggou.top/imgs/2019/07/200501092691998.png)

由上图可以看出，进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。

linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：

vm_area_struct结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个vm_ops指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从vm_area_struct中获得。mmap函数就是要创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连。具体步骤请看下一节。



## 二、benchmark

通常使用mmap()的三种情况.提高I/O效率、匿名内存映射、共享内存进程通信。

那么通过mmap映射的空间和内存、磁盘的IO性能上有何差异呢？

计算写的速度：

写磁盘速度：*16.55M/s*

写*mmap*映射的空间速度：*63.04M/s*

写内存的速度：*125.02M/s*

由此可见，由*mmap*映射的空间的读写速度比直接读写磁盘的速度快。

那么，为什么会快呢？这就需要从*mmap*实现的原理来分析了。

*在此图中，**“**起始地址**”**是**mmap**的返回值。在图中，映射存储区位于堆和栈之间*。

https://www.cnblogs.com/huxiao-tee/p/4660352.html

mmap用法：https://blog.csdn.net/acs713/article/details/8585670
```
*方法介绍：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
 *将文件映射到内存
 */
#include <unistd.h> 
#include <sys/mman.h> 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl.h> 
int main()
{
    int fp,i;
    char * buf;
    if((fp = open("test_data.txt",O_RDONLY)) < 0 )  //test_data 文件内容为hello, world!
    {
          return 0;
    }
    buf = mmap(0, 12, PROT_READ, MAP_PRIVATE, fp,0);
    for (i=0; i<12; i++)
        printf("%c\n", buf[i]);
    return 0;
}
```

## 三、mmap内存映射原理

**(1)进程启动映射过程，并在当前进程的虚拟地址空间中为映射创建虚拟映射区域**

为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化

将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中

**(2)调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系**

为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。

通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。

内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。

通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。

**(3)进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝**

进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。

缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。

调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。

之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。

注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。



## 四、mmap和常规文件操作的区别

常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。

而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。

**常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。**


